"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const Fragment_1 = __importDefault(require("./Fragment"));
const renderer_1 = require("@react-pdf/renderer");
const ModelContext_1 = require("./contexts/ModelContext");
const ConfigContext_1 = require("./contexts/ConfigContext");
const StylesheetContext_1 = require("./contexts/StylesheetContext");
const SuggestionsContext_1 = require("./contexts/SuggestionsContext");
const Document = ({ document = { fragments: [], config: {}, model: {}, suggestions: {} } }) => {
    Object.values((document.stylesheet || {}).fonts || {}).forEach((f) => renderer_1.Font.register(f));
    return (react_1.default.createElement(StylesheetContext_1.StylesheetProvider, { value: document.stylesheet },
        react_1.default.createElement(ModelContext_1.ModelProvider, { value: document.model },
            react_1.default.createElement(renderer_1.Document, null, (document.fragments || []).map((f, i) => (react_1.default.createElement(ConfigContext_1.ConfigProvider, { key: i, value: (document.config || {})[f.id] || {} },
                react_1.default.createElement(SuggestionsContext_1.SuggestionsProvider, { key: i, value: (document.suggestions || {}).ids || {} },
                    react_1.default.createElement(Fragment_1.default, { fragment: f })))))))));
};
exports.default = Document;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG9jdW1lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvRG9jdW1lbnQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0RBQTJDO0FBQzNDLDBEQUFrQztBQUNsQyxrREFBdUU7QUFDdkUsMERBQXNEO0FBQ3RELDREQUF3RDtBQUN4RCxvRUFBZ0U7QUFDaEUsc0VBQWtFO0FBRWxFLE1BQU0sUUFBUSxHQUFpQyxDQUFDLEVBQUMsUUFBUSxHQUFHLEVBQUMsU0FBUyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBQyxFQUFnQixFQUFFLEVBQUU7SUFDbkksTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLElBQUksRUFBRSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsZUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFRLENBQUMsQ0FBQyxDQUFBO0lBQzlGLE9BQU8sQ0FDSCw4QkFBQyxzQ0FBa0IsSUFBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLFVBQWlDO1FBQ2pFLDhCQUFDLDRCQUFhLElBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxLQUFLO1lBQ2hDLDhCQUFDLG1CQUFnQixRQUNYLENBQUMsUUFBUSxDQUFDLFNBQVMsSUFBSSxFQUFFLENBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUNqRCw4QkFBQyw4QkFBYyxJQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRTtnQkFDOUQsOEJBQUMsd0NBQW1CLElBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxRQUFRLENBQUMsV0FBVyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUFFO29CQUN0RSw4QkFBQyxrQkFBUSxJQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUksQ0FDUCxDQUNULENBQ3BCLENBQUMsQ0FDYSxDQUNQLENBQ0MsQ0FDeEIsQ0FBQztBQUNOLENBQUMsQ0FBQTtBQUtELGtCQUFlLFFBQVEsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwge0NvbXBvbmVudFR5cGV9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBGcmFnbWVudCBmcm9tICcuL0ZyYWdtZW50JztcbmltcG9ydCB7RG9jdW1lbnQgYXMgUmVuZGVyZXJEb2N1bWVudCwgRm9udH0gZnJvbSAnQHJlYWN0LXBkZi9yZW5kZXJlcic7XG5pbXBvcnQge01vZGVsUHJvdmlkZXJ9IGZyb20gJy4vY29udGV4dHMvTW9kZWxDb250ZXh0JztcbmltcG9ydCB7Q29uZmlnUHJvdmlkZXJ9IGZyb20gJy4vY29udGV4dHMvQ29uZmlnQ29udGV4dCc7XG5pbXBvcnQge1N0eWxlc2hlZXRQcm92aWRlcn0gZnJvbSAnLi9jb250ZXh0cy9TdHlsZXNoZWV0Q29udGV4dCc7XG5pbXBvcnQge1N1Z2dlc3Rpb25zUHJvdmlkZXJ9IGZyb20gJy4vY29udGV4dHMvU3VnZ2VzdGlvbnNDb250ZXh0JztcbmltcG9ydCB7ZG9jdW1lbnRfZGVmaW5pdGlvbiwgZG9jdW1lbnRfc3R5bGVzaGVldH0gZnJvbSBcIi4vdHlwZXNcIjtcbmNvbnN0IERvY3VtZW50OiBDb21wb25lbnRUeXBlPERvY3VtZW50UHJvcHM+ID0gKHtkb2N1bWVudCA9IHtmcmFnbWVudHM6IFtdLCBjb25maWc6IHt9LCBtb2RlbDoge30sIHN1Z2dlc3Rpb25zOiB7fX19OiBEb2N1bWVudFByb3BzKSA9PiB7XG4gICAgT2JqZWN0LnZhbHVlcygoZG9jdW1lbnQuc3R5bGVzaGVldCB8fCB7fSkuZm9udHMgfHwge30pLmZvckVhY2goKGYpID0+IEZvbnQucmVnaXN0ZXIoZiBhcyBhbnkpKVxuICAgIHJldHVybiAoXG4gICAgICAgIDxTdHlsZXNoZWV0UHJvdmlkZXIgdmFsdWU9e2RvY3VtZW50LnN0eWxlc2hlZXQgYXMgZG9jdW1lbnRfc3R5bGVzaGVldH0+XG4gICAgICAgICAgICA8TW9kZWxQcm92aWRlciB2YWx1ZT17ZG9jdW1lbnQubW9kZWx9PlxuICAgICAgICAgICAgICAgIDxSZW5kZXJlckRvY3VtZW50PlxuICAgICAgICAgICAgICAgICAgICB7KChkb2N1bWVudC5mcmFnbWVudHMgfHwgW10pIGFzIGFueVtdKS5tYXAoKGYsIGkpID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDb25maWdQcm92aWRlciBrZXk9e2l9IHZhbHVlPXsoZG9jdW1lbnQuY29uZmlnIHx8IHt9KVtmLmlkXSB8fCB7fX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFN1Z2dlc3Rpb25zUHJvdmlkZXIga2V5PXtpfSB2YWx1ZT17KGRvY3VtZW50LnN1Z2dlc3Rpb25zIHx8IHt9KS5pZHMgfHwge319PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RnJhZ21lbnQgZnJhZ21lbnQ9e2Z9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9TdWdnZXN0aW9uc1Byb3ZpZGVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Db25maWdQcm92aWRlcj5cbiAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgPC9SZW5kZXJlckRvY3VtZW50PlxuICAgICAgICAgICAgPC9Nb2RlbFByb3ZpZGVyPlxuICAgICAgICA8L1N0eWxlc2hlZXRQcm92aWRlcj5cbiAgICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvY3VtZW50UHJvcHMge1xuICAgIGRvY3VtZW50PzogZG9jdW1lbnRfZGVmaW5pdGlvbixcbn1cbmV4cG9ydCBkZWZhdWx0IERvY3VtZW50Il19