"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const lambda_utils_1 = require("@ohoareau/lambda-utils");
const availableSources = __importStar(require("../sources"));
const docx_1 = require("docx");
async function render(def) {
    const doc = new docx_1.Document();
    doc.addSection({
        properties: {},
        children: [
            new docx_1.Paragraph({
                children: [
                    new docx_1.TextRun("Hello World"),
                    new docx_1.TextRun({
                        text: "Foo Bar",
                        bold: true,
                    }),
                    new docx_1.TextRun({
                        text: "\tGithub is the best",
                        bold: true,
                    }),
                ],
            }),
        ],
    });
    return docx_1.Packer.toBuffer(doc);
}
async function generate(ctx) {
    const sources = { ...availableSources, ...(ctx.config.sources || {}) };
    const sourceName = ctx.query.source || 'default';
    const source = sources[sourceName];
    if (!source)
        return ctx.helpers.httpNotFound();
    const sourced = (await source(ctx)) || {};
    if (!sourced || !sourced.definition)
        return ctx.helpers.httpNotFound();
    try {
        return ctx.helpers.buffer({ contentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', ...sourced, buffer: await render(sourced.definition) });
    }
    catch (e) {
        throw new lambda_utils_1.UnderlyingExecutionError(e, 'generate', { sourceName });
    }
}
exports.generate = generate;
exports.default = generate;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYWN0aW9ucy9nZW5lcmF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSx5REFBb0Y7QUFDcEYsNkRBQStDO0FBQy9DLCtCQUE0RDtBQUU1RCxLQUFLLFVBQVUsTUFBTSxDQUFDLEdBQVE7SUFDMUIsTUFBTSxHQUFHLEdBQUcsSUFBSSxlQUFRLEVBQUUsQ0FBQztJQUczQixHQUFHLENBQUMsVUFBVSxDQUFDO1FBQ1gsVUFBVSxFQUFFLEVBQUU7UUFDZCxRQUFRLEVBQUU7WUFDTixJQUFJLGdCQUFTLENBQUM7Z0JBQ1YsUUFBUSxFQUFFO29CQUNOLElBQUksY0FBTyxDQUFDLGFBQWEsQ0FBQztvQkFDMUIsSUFBSSxjQUFPLENBQUM7d0JBQ1IsSUFBSSxFQUFFLFNBQVM7d0JBQ2YsSUFBSSxFQUFFLElBQUk7cUJBQ2IsQ0FBQztvQkFDRixJQUFJLGNBQU8sQ0FBQzt3QkFDUixJQUFJLEVBQUUsc0JBQXNCO3dCQUM1QixJQUFJLEVBQUUsSUFBSTtxQkFDYixDQUFDO2lCQUNMO2FBQ0osQ0FBQztTQUNMO0tBQ0osQ0FBQyxDQUFDO0lBRUgsT0FBTyxhQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2hDLENBQUM7QUFFTSxLQUFLLFVBQVUsUUFBUSxDQUFDLEdBQVE7SUFDbkMsTUFBTSxPQUFPLEdBQUcsRUFBQyxHQUFHLGdCQUFnQixFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsRUFBQyxDQUFDO0lBQ3JFLE1BQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxJQUFJLFNBQVMsQ0FBQztJQUNqRCxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDbkMsSUFBSSxDQUFDLE1BQU07UUFBRSxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDL0MsTUFBTSxPQUFPLEdBQUcsQ0FBQyxNQUFNLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUMxQyxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVU7UUFBRSxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDdkUsSUFBSTtRQUNBLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBQyxXQUFXLEVBQUUseUVBQXlFLEVBQUUsR0FBRyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsRUFBQyxDQUFDLENBQUM7S0FDN0s7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNSLE1BQU0sSUFBSSx1Q0FBd0IsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLEVBQUMsVUFBVSxFQUFDLENBQUMsQ0FBQztLQUNuRTtBQUNMLENBQUM7QUFaRCw0QkFZQztBQUVELGtCQUFlLFFBQVEsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y3R4LCBodHRwX3Jlc3BvbnNlLCBVbmRlcmx5aW5nRXhlY3V0aW9uRXJyb3J9IGZyb20gXCJAb2hvYXJlYXUvbGFtYmRhLXV0aWxzXCI7XG5pbXBvcnQgKiBhcyBhdmFpbGFibGVTb3VyY2VzIGZyb20gXCIuLi9zb3VyY2VzXCI7XG5pbXBvcnQgeyBEb2N1bWVudCwgUGFja2VyLCBQYXJhZ3JhcGgsIFRleHRSdW4gfSBmcm9tICdkb2N4JztcblxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyKGRlZjogYW55KSB7XG4gICAgY29uc3QgZG9jID0gbmV3IERvY3VtZW50KCk7XG5cbiAgICAvLyBAdG9kb1xuICAgIGRvYy5hZGRTZWN0aW9uKHtcbiAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICBuZXcgVGV4dFJ1bihcIkhlbGxvIFdvcmxkXCIpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIkZvbyBCYXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlxcdEdpdGh1YiBpcyB0aGUgYmVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFBhY2tlci50b0J1ZmZlcihkb2MpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGUoY3R4OiBjdHgpOiBQcm9taXNlPGh0dHBfcmVzcG9uc2U+IHtcbiAgICBjb25zdCBzb3VyY2VzID0gey4uLmF2YWlsYWJsZVNvdXJjZXMsIC4uLihjdHguY29uZmlnLnNvdXJjZXMgfHwge30pfTtcbiAgICBjb25zdCBzb3VyY2VOYW1lID0gY3R4LnF1ZXJ5LnNvdXJjZSB8fCAnZGVmYXVsdCc7XG4gICAgY29uc3Qgc291cmNlID0gc291cmNlc1tzb3VyY2VOYW1lXTtcbiAgICBpZiAoIXNvdXJjZSkgcmV0dXJuIGN0eC5oZWxwZXJzLmh0dHBOb3RGb3VuZCgpO1xuICAgIGNvbnN0IHNvdXJjZWQgPSAoYXdhaXQgc291cmNlKGN0eCkpIHx8IHt9O1xuICAgIGlmICghc291cmNlZCB8fCAhc291cmNlZC5kZWZpbml0aW9uKSByZXR1cm4gY3R4LmhlbHBlcnMuaHR0cE5vdEZvdW5kKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGN0eC5oZWxwZXJzLmJ1ZmZlcih7Y29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsIC4uLnNvdXJjZWQsIGJ1ZmZlcjogYXdhaXQgcmVuZGVyKHNvdXJjZWQuZGVmaW5pdGlvbil9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmRlcmx5aW5nRXhlY3V0aW9uRXJyb3IoZSwgJ2dlbmVyYXRlJywge3NvdXJjZU5hbWV9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdlbmVyYXRlIl19