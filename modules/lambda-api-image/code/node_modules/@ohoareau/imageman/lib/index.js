"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const sharp_1 = __importDefault(require("sharp"));
const availableOperations = __importStar(require("./operations"));
const utils_1 = require("./utils");
async function build({ input, operations = [], output, format = undefined, sourceTypes = {}, targetTypes = {} }) {
    const source = await utils_1.fetch(input, sourceTypes);
    let img = (await operations.reduce(async (acc, operation) => {
        acc = (await acc) || acc;
        try {
            if (!availableOperations[operation.type]) {
                throw new Error(`Unknown operation: ${operation.type}`);
            }
            return (await availableOperations[operation.type](acc, operation)) || acc;
        }
        catch (e) {
            console.warn(`Warning: ${operation.type} - ${e.message}`);
            return acc;
        }
    }, Promise.resolve(sharp_1.default(source, { sequentialRead: true }))));
    const { format: finalFormat, target } = await utils_1.describeTarget(output, format);
    finalFormat && (img = await utils_1.applyFormat(img, finalFormat));
    return utils_1.save(img, target, targetTypes);
}
var utils_2 = require("./utils");
exports.detectFormatFromFileName = utils_2.detectFormatFromFileName;
exports.default = build;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQ0Esa0RBQTBCO0FBQzFCLGtFQUFtRDtBQUNuRCxtQ0FBaUU7QUFFakUsS0FBSyxVQUFVLEtBQUssQ0FBQyxFQUFDLEtBQUssRUFBRSxVQUFVLEdBQUcsRUFBRSxFQUFFLE1BQU0sRUFBRSxNQUFNLEdBQUcsU0FBUyxFQUFFLFdBQVcsR0FBRyxFQUFFLEVBQUUsV0FBVyxHQUFHLEVBQUUsRUFBZ0I7SUFDeEgsTUFBTSxNQUFNLEdBQUcsTUFBTSxhQUFLLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBMEIsQ0FBQTtJQUN2RSxJQUFJLEdBQUcsR0FBRyxDQUFDLE1BQU0sVUFBVSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxFQUFFO1FBQ3hELEdBQUcsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDO1FBQ3pCLElBQUc7WUFDQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUV0QyxNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixTQUFTLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQzthQUMzRDtZQUNELE9BQU8sQ0FBQyxNQUFNLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUU7U0FDOUU7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNSLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxTQUFTLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBQzFELE9BQU8sR0FBRyxDQUFDO1NBQ2Q7SUFFTCxDQUFDLEVBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxlQUFLLENBQUMsTUFBTSxFQUFFLEVBQUMsY0FBYyxFQUFFLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUQsTUFBTSxFQUFDLE1BQU0sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFDLEdBQUcsTUFBTSxzQkFBYyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztJQUMzRSxXQUFXLElBQUksQ0FBQyxHQUFHLEdBQUcsTUFBTSxtQkFBVyxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQzNELE9BQU8sWUFBSSxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDMUMsQ0FBQztBQUVELGlDQUFpRDtBQUF6QywyQ0FBQSx3QkFBd0IsQ0FBQTtBQUdoQyxrQkFBZSxLQUFLLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2ltYWdlbWFuX2FyZ3N9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHNoYXJwIGZyb20gJ3NoYXJwJztcbmltcG9ydCAqIGFzIGF2YWlsYWJsZU9wZXJhdGlvbnMgZnJvbSAnLi9vcGVyYXRpb25zJ1xuaW1wb3J0IHthcHBseUZvcm1hdCwgZGVzY3JpYmVUYXJnZXQsIHNhdmUsIGZldGNofSBmcm9tIFwiLi91dGlsc1wiO1xuXG5hc3luYyBmdW5jdGlvbiBidWlsZCh7aW5wdXQsIG9wZXJhdGlvbnMgPSBbXSwgb3V0cHV0LCBmb3JtYXQgPSB1bmRlZmluZWQsIHNvdXJjZVR5cGVzID0ge30sIHRhcmdldFR5cGVzID0ge319OiBpbWFnZW1hbl9hcmdzKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXdhaXQgZmV0Y2goaW5wdXQsIHNvdXJjZVR5cGVzKSBhcyBCdWZmZXJ8UmVhZGFibGVTdHJlYW1cbiAgICBsZXQgaW1nID0gKGF3YWl0IG9wZXJhdGlvbnMucmVkdWNlKGFzeW5jIChhY2MsIG9wZXJhdGlvbikgPT4ge1xuICAgICAgICBhY2MgPSAoYXdhaXQgYWNjKSB8fCBhY2M7XG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIGlmICghYXZhaWxhYmxlT3BlcmF0aW9uc1tvcGVyYXRpb24udHlwZV0pIHtcbiAgICAgICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gRXhjZXB0aW9uQ2F1Z2h0TG9jYWxseUpTXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9wZXJhdGlvbjogJHtvcGVyYXRpb24udHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgYXZhaWxhYmxlT3BlcmF0aW9uc1tvcGVyYXRpb24udHlwZV0oYWNjLCBvcGVyYXRpb24pKSB8fCBhY2MgO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6ICR7b3BlcmF0aW9uLnR5cGV9IC0gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG5cbiAgICB9LCBQcm9taXNlLnJlc29sdmUoc2hhcnAoc291cmNlLCB7c2VxdWVudGlhbFJlYWQ6IHRydWV9KSkpKTtcbiAgICBjb25zdCB7Zm9ybWF0OiBmaW5hbEZvcm1hdCwgdGFyZ2V0fSA9IGF3YWl0IGRlc2NyaWJlVGFyZ2V0KG91dHB1dCwgZm9ybWF0KTtcbiAgICBmaW5hbEZvcm1hdCAmJiAoaW1nID0gYXdhaXQgYXBwbHlGb3JtYXQoaW1nLCBmaW5hbEZvcm1hdCkpO1xuICAgIHJldHVybiBzYXZlKGltZywgdGFyZ2V0LCB0YXJnZXRUeXBlcyk7XG59XG5cbmV4cG9ydCB7ZGV0ZWN0Rm9ybWF0RnJvbUZpbGVOYW1lfSBmcm9tICcuL3V0aWxzJztcbmV4cG9ydCB7aW1hZ2VtYW5fYXJnc30gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkIl19